*kernel/blk_drv/hd.c*



## 关于硬盘版本号

设备号`306`这是Linux老式的硬盘命名方式，具体值的含义如下：

设备号=主设备号*256 +次设备号（也即dev_no = (major<<8) + minor），其中主设备号：1-内存，2-磁盘，3-硬盘，4-ttyx，5-tty，6-并行口，7-非命名管道。

硬盘的逻辑设备号（主设备号为3）

| 逻辑设备号 | 对应设备文件 | 说明                     |
| ---------- | ------------ | ------------------------ |
| 0x300      | /dev/hd0     | 代表整个第1个硬盘        |
| 0x301      | /dev/hd1     | 表示第1个硬盘的第1个分区 |
| 0x302      | /dev/hd2     | 表示第1个硬盘的第2个分区 |
| 0x303      | /dev/hd3     | 表示第1个硬盘的第3个分区 |
| 0x304      | /dev/hd4     | 表示第1个硬盘的第4个分区 |
| 0x305      | /dev/hd5     | 代表整个第2个硬盘        |
| 0x306      | /dev/hd6     | 表示第2个硬盘的第1个分区 |
| 0x307      | /dev/hd7     | 表示第2个硬盘的第2个分区 |
| 0x308      | /dev/hd8     | 表示第2个硬盘的第3个分区 |
| 0x309      | /dev/hd9     | 表示第2个硬盘的第4个分区 |

## 硬盘系统初始化

设置硬盘中断描述符，并允许硬盘控制器发送中断请求信号。该函数设置硬盘设备的请求项处理函数指针为`do_hd_request()`,然后设置硬盘中断门描述符。`hd_interrupt`(kernel/system_call.s)是其中断处理过程。硬盘中断号为`int 0x2E(46)`,对应8259A芯片的中断请求信号IRQ13.接着复位接联的主8250A int2 的屏蔽位，允许从片发出中断请求信号。再复位硬盘的中断请求屏蔽位(在从片上)，允许硬盘控制器发送中断信号。中断描述符表IDT内中断门描述符设置宏`set_intr_gate()`。

*kernel/blk_drv/hd.c*

```c
void hd_init(void)
{
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;      // do_hd_request()
	set_intr_gate(0x2E,&hd_interrupt);
	outb_p(inb_p(0x21)&0xfb,0x21);                      // 复位接联的主8259A int2的屏蔽位
	outb(inb_p(0xA1)&0xbf,0xA1);                        // 复位硬盘中断请求屏蔽位(在从片上)
}
```

这里讲的是硬盘，所以`MAJOR_NR`就是`3`,`DEVICE_REQUEST`就是`do_hd_request`

## 加载文件系统

*kernel/blk_drv/hd.c*

在执行`setup.s`程序后，`0x90080`这个地址存放的是硬盘的参数

```c
int sys_setup(void * BIOS)
{
	static int callable = 1;
	int i,drive;
	unsigned char cmos_disks;
	struct partition *p;
	struct buffer_head * bh;

	if (!callable)
		return -1;
	callable = 0;

// 如果没有在config.h 中定义硬盘参数，就从0x90080 处读入
#ifndef HD_TYPE
	for (drive=0 ; drive<2 ; drive++) {
		hd_info[drive].cyl = *(unsigned short *) BIOS;        // 柱面数
		hd_info[drive].head = *(unsigned char *) (2+BIOS);    // 磁头数
		hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);  // 写前预补偿柱面号
		hd_info[drive].ctl = *(unsigned char *) (8+BIOS);     // 控制字节
		hd_info[drive].lzone = *(unsigned short *) (12+BIOS); // 磁头着陆区柱面号	
		hd_info[drive].sect = *(unsigned char *) (14+BIOS);   // 每磁道扇区
		BIOS += 16;                                           // 每个硬盘的参数表长16 字节，这里BIOS 指向下一个表 
	}
    // setup.s程序里如果没有第二个硬盘信息，那么这16字节的空间会被清0的
    // 所以这里查看第二个硬盘的柱面数，为0说明没有第二个硬盘
	if (hd_info[1].cyl)
		NR_HD=2;
	else
		NR_HD=1;
#endif
    
    // 设置每个硬盘的起始扇区号和扇区总数
	for (i=0 ; i<NR_HD ; i++) {
		hd[i*5].start_sect = 0;                                               // 硬盘起始扇区号
		hd[i*5].nr_sects = hd_info[i].head * hd_info[i].sect*hd_info[i].cyl;  // 硬盘总扇区数    
	}

	/*
		We querry CMOS about hard disks : it could be that 
		we have a SCSI/ESDI/etc controller that is BIOS
		compatable with ST-506, and thus showing up in our
		BIOS table, but not register compatable, and therefore
		not present in CMOS.

		Furthurmore, we will assume that our ST-506 drives
		<if any> are the primary drives in the system, and 
		the ones reflected as drive 1 or 2.

		The first drive is stored in the high nibble of CMOS
		byte 0x12, the second in the low nibble.  This will be
		either a 4 bit drive type or 0xf indicating use byte 0x19 
		for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.

		Needless to say, a non-zero value means we have 
		an AT controller hard disk for that drive.

		
	*/

    // 检测硬盘到底是否是AT 控制器兼容的
	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
		if (cmos_disks & 0x0f)
			NR_HD = 2;
		else
			NR_HD = 1;
	else
		NR_HD = 0;
    
    // 若NR_HD=0，则两个硬盘都不是AT 控制器兼容的，硬盘数据结构清零。
    // 若NR_HD=1，则将第2 个硬盘的参数清零。
	for (i = NR_HD ; i < 2 ; i++) {
		hd[i*5].start_sect = 0;
		hd[i*5].nr_sects = 0;
	}
    
    // 读取每一个硬盘上第1 块数据（第1 个扇区有用），获取其中的分区表信息。
    // 首先利用函数bread()读硬盘第1 块数据(fs/buffer.c,267)，参数中的0x300 是硬盘的主设备号
    // 然后根据硬盘头1 个扇区位置0x1fe 处的两个字节是否为'55AA'来判断该扇区中位于0x1BE 开始的
    // 分区表是否有效。最后将分区表信息放入硬盘分区数据结构hd 中。
	for (drive=0 ; drive<NR_HD ; drive++) {
		if (!(bh = bread(0x300 + drive*5,0))) {
			printk("Unable to read partition table of drive %d\n\r",
				drive);
			panic("");
		}
		if (bh->b_data[510] != 0x55 || (unsigned char)
		    bh->b_data[511] != 0xAA) {
			printk("Bad partition table on drive %d\n\r",drive);
			panic("");
		}
		p = 0x1BE + (void *)bh->b_data;  // 分区表位于硬盘第1 扇区的 0x1BE 处
		for (i=1;i<5;i++,p++) {
			hd[i+5*drive].start_sect = p->start_sect;
			hd[i+5*drive].nr_sects = p->nr_sects;
		}
		brelse(bh);  // 释放为存放硬盘块而申请的内存缓冲区页
	}
	if (NR_HD)
		printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
	rd_load();  // 加载（创建）RAMDISK(kernel/blk_drv/ramdisk.c)
	mount_root(); // 安装根文件系统
	return (0);
}
```







