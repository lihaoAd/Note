## 特殊字符

|字符|含义|
|:-|:-|
| $    | 匹配一行的结尾。要匹配 $ 字符本身，请使用`\$`                |
| ^    | 匹配一行的开头。要匹配 ^ 字符本身，请使用`\^`                |
| ()   | 标记子表达式的开始和结束位置。要匹配这些字符，请使用`\(`和`\)` |
| []   | 用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用`\[`和`\]` |
| {}   | 用于标记前面子表达式的出现频度。要匹配这些字符，请使用`\{`和`\}` |
| *    | 指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用`\*` |
| +    | 指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用`\+` |
| ?    | 指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用`\?` |
| .    | 匹配除换行符`\n`之外的任何单字符。要匹配`.`字符本身，请使用`\.` |
| \    | 用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配`\`字符，请用`\\` |
| \|   | 指定两项之间任选一项。如果要匹配`丨`字符本身，请使用`\|`     |

## 预定义字符

| 预定义字符 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| .          | 可以匹配任何字符                                             |
| \d         | 匹配 0~9 的所有数字                                          |
| \D         | 匹配非数字                                                   |
| \s         | 匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等 |
| \S         | 匹配所有的非空白字符                                         |
| \w         | 匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线`_` |
| \W         | 匹配所有的非单词字符                                         |



## 方括号表达式

| 方括号表达式     | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| 表示枚举         | 例如`[abc]`表示 a、b、c 其中任意一个字符；`[gz]`表示 g、z 其中任意一个字符 |
| 表示范围：-      | 例如`[a-f]`表示 a~f 范围内的任意字符；`[\\u0041-\\u0056]`表示十六进制字符 \u0041 到 \u0056 范围的字符。范围可以和枚举结合使用，如`[a-cx-z]`，表示 a~c、x~z 范围内的任意字符 |
| 表示求否：^      | 例如`[^abc]`表示非 a、b、c 的任意字符；`[^a-f]`表示不是 a~f 范围内的任意字符 |
| 表示“与”运算：&& | 例如 `[a-z&&[def]]`是 a~z 和 [def] 的交集，表示 d、e `f[a-z&&^bc]]`是 a~z 范围内的所有字符，除 b 和 c 之外 `[ad-z] [a-z&&[m-p]]`是 a~z 范围内的所有字符，除 m~p 范围之外的字符 |
| 表示“并”运算     | 并运算与前面的枚举类似。例如`[a-d[m-p]]`表示 `[a-dm-p]`        |

## 边界匹配符



| 边界匹配符 | 说明                           |
| ---------- | ------------------------------ |
| ^          | 行的开头                       |
| $          | 行的结尾                       |
| \b         | 单词的边界                     |
| \B         | 非单词的边界                   |
| \A         | 输入的开头                     |
| \G         | 前一个匹配的结尾               |
| \Z         | 输入的结尾，仅用于最后的结束符 |
| \z         | 输入的结尾                     |

## POSIX 字符类

| POSIX 字符 | 含义                |
| ---------- | ------------------- |
| \p{Lower}  | 小写字母字符：`[a-z]` |
|\p{Upper}|  大写字母字符：`[A-Z]`|
|\p{ASCII}  |所有 ASCII：`[\x00-\x7F]`|
|\p{Alpha}  |字母字符：`[\p{Lower}\p{Upper}]`|
|\p{Digit}  |十进制数字：`[0-9]`|
|\p{Alnum} | 字母数字字符：`[\p{Alpha}\p{Digit}]`|
|\p{Punct} | 标点符号：`!"#$%&'()*+,-./:;<=>?@[\]^_``{|}\~` |
|\p{Graph} | 可见字符：`[\p{Alnum}\p{Punct}]`|
|\p{Print} | 可打印字符：`[\p{Graph}\x20]`|
|\p{Blank}  |空格或制表符：`[ \t]`|
|\p{Cntrl} | 控制字符：`[\x00-\x1F\x7F]`|
|\p{XDigit}  |十六进制数字：`[0-9a-fA-F]`|
|\p{Space} | 空白字符：`[ \t\n\x0B\f\r]`|



## 捕获组

### 普通捕获组(Expression)

正则表达式左侧开始，每出现一个左括号"("记做一个分组，分组编号从 1 开始。0 代表整个表达式。

对于时间字符串：2017-04-25，表达式如下

```
(\\d{4})-((\\d{2})-(\\d{2}))
```

| 编号 | 捕获组                    | 匹配       |
| :--- | :------------------------ | :--------- |
| 0    | (\d{4})-((\d{2})-(\d{2})) | 2017-04-25 |
| 1    | (\d{4})                   | 2017       |
| 2    | ((\d{2})-(\d{2}))         | 04-25      |
| 3    | (\d{2})                   | 04         |
| 4    | (\d{2})                   | 25         |

### 命名捕获组(?Expression)

每个以左括号开始的捕获组，都紧跟着 **?**，而后才是正则表达式。

对于时间字符串：2017-04-25，表达式如下:

```
(?<year>\\d{4})-(?<md>(?<month>\\d{2})-(?<date>\\d{2}))
```

```java
Pattern regex = Pattern.compile("(?<year>\\d{4})-(?<md>(?<month>\\d{2})-(?<date>\\d{2}))");
Matcher matcher = regex.matcher("2017-04-25");
System.out.println(matcher.matches());
System.out.printf("\n matcher.group(0) value:%s", matcher.group(0));
System.out.printf("\n matcher.group('year') value:%s", matcher.group("year"));
System.out.printf("\n matcher.group('md') value:%s", matcher.group("md"));
System.out.printf("\n matcher.group('month') value:%s", matcher.group("month"));
System.out.printf("\n matcher.group('date') value:%s", matcher.group("date"));
```

## 非捕获组

在左括号后紧跟 **?:**，而后再加上正则表达式，构成非捕获组 **(?:Expression)**。

对于时间字符串：2017-04-25，表达式如下:

```
(?:\\d{4})-((\\d{2})-(\\d{2}))
```

这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组 **(?:\d{4})**，其实是被忽略的。当使用 matcher.group(4) 时，系统会报错。

| 编号 | 捕获组                    | 匹配       |
| :--- | :------------------------ | :--------- |
| 0    | (\d{4})-((\d{2})-(\d{2})) | 2017-04-25 |
| 1    | ((\d{2})-(\d{2}))         | 04-25      |
| 2    | (\d{2})                   | 04         |
| 3    | (\d{2})                   | 25         |

```java
Pattern regex = Pattern.compile("(?:\\d{4})-((\\d{2})-(\\d{2}))");
Matcher matcher = regex.matcher("2017-04-25");
System.out.println(matcher.matches());
System.out.printf("\n matcher.group(0) value:%s", matcher.group(0));  // 2017-04-25
System.out.printf("\n matcher.group(1) value:%s", matcher.group(1));  // 04-25
System.out.printf("\n matcher.group(2) value:%s", matcher.group(2));  // 04
System.out.printf("\n matcher.group(3) value:%s", matcher.group(3));  // 25
```



##  贪婪模式（Greedy）

在数量匹配中，如果单独使用+、？、*、{min,max}等量词，正则表达式会匹配**尽可能多**的内容
|贪婪模式|含义|
|:-|:-|
|X?  |X，一次或一次也没有|
|X* | X，零次或多次|
|X+  |X，一次或多次|
|X{n} | X，恰好 n 次|
|X{n,} | X，至少 n 次|
|X{n,m} | X，至少 n 次，但是不超过 m 次|



## 懒惰模式（Reluctant）

在懒惰模式下，正则表达式会**尽可能少**地重复匹配字符，如果匹配成功，会继续匹配剩余的字符串，使用?开启懒惰模式
|懒惰模式|含义|
|:-|:-|
|X??  |X，一次或一次也没有|
|X*? | X，零次或多次|
|X+?  |X，一次或多次|
|X{n}? | X，恰好 n 次|
|X{n,}?  |X，至少 n 次|
|X{n,m}?  |X，至少 n 次，但是不超过 m 次|



## 独占模式（Possessive）

和贪婪模式一样，独占模式一样会**最大限度**地匹配更多内容，使用+开启懒惰模式
|独占模式|含义|
|:-|:-|
|X?+  |X，一次或一次也没有|
|X*+ | X，零次或多次|
|X++ | X，一次或多次|
|X{n}+ | X，恰好 n 次|
|X{n,}+  |X，至少 n 次|
|X{n,m}+ | X，至少 n 次，但是不超过 m 次|

## 零宽度断言匹配

在使用正则表达式时，有时我们需要捕获的内容前后必须是特定内容，但又不捕获这些特定内容的时候，零宽断言就起到作用了。它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。

### 正向零宽先行断言

- (?=exp) 零宽度向前匹配

- (?!exp) 零宽度向前非匹配

```java
// 匹配后面跟随任意一个小写字母的字符串"ab
Pattern regex = Pattern.compile("ab(?=[a-z])");
Matcher matcher = regex.matcher("dsdsdfsabdfff");
while (matcher.find()){
    System.out.println(matcher.start()); // 7
}
```

```java
// 匹配后面不跟随任意一个字母d的字符串"ab"
Pattern regex = Pattern.compile("ab(?!d)");
Matcher matcher = regex.matcher("dsdsabcfsabdfff");
while (matcher.find()){
    System.out.println(matcher.start()); // 4
}
```





### 负向零宽先行断言

- (?<=exp) 零宽度向后匹配
- (?<!exp) 零宽度向后非匹配

```java
// 匹配前面跟随任意一个字母s的字符串"ab
Pattern regex = Pattern.compile("(?<=s)ab");
Matcher matcher = regex.matcher("dsdsabcftabdfff");
while (matcher.find()){
    System.out.println(matcher.start()); // 4
}
```

```java
// 匹配前面不跟随任意一个字母s的字符串"ab"
Pattern regex = Pattern.compile("(?<!s)ab");
Matcher matcher = regex.matcher("dsdsabcftabdfff");
while (matcher.find()){
    System.out.println(matcher.start()); // 9
}
```



## 优化

1. 少用贪婪模式，**多用独占模式**（避免回溯）
2. **减少分支选择**，分支选择类型"(X|Y|Z)"的正则表达式会**降低性能**，尽量减少使用，如果一定要使用
3. 考虑选择的顺序，将比较常用的选择放在前面，使它们可以较快地被匹配
4. 提取共用模式，(abcd|abef) => ab(cd|ef)
5. 如果是简单的分支选择类型，可以用三次index代替(X|Y|Z)
6. 减少捕获嵌套
   - 捕获组：把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，一般一个()就是一个捕获组
   - 每个捕获组都有一个编号，编号0代表整个匹配到的内容
   - 非捕获组：参与匹配却**不进行分组编号**的捕获组，其表达式一般由(?:exp)组成
   - 减少不需要获取的分组，可以提高正则表达式的性能