## 最大公约数（Greatest Common Divisor(GCD)）

最大公因数，也称最大[公约数](https://baike.baidu.com/item/公约数)、最大公[因子](https://baike.baidu.com/item/因子)，指两个或多个[整数](https://baike.baidu.com/item/整数/1293937)共有[约数](https://baike.baidu.com/item/约数/8417882)中最大的一个。a，b的最大公约数记为`（a，b）`，同样的，a，b，c的最大[公约](https://baike.baidu.com/item/公约)数记为`（a，b，c）`，多个[整数](https://baike.baidu.com/item/整数/1293937)的最大公约数也有同样的记号。求最大公约数有多种[方法](https://baike.baidu.com/item/方法/2444)，常见的有[质因数分解](https://baike.baidu.com/item/质因数分解)法、[短除法](https://baike.baidu.com/item/短除法/3640958)、[辗转相除法](https://baike.baidu.com/item/辗转相除法/4625352)、[更相减损法](https://baike.baidu.com/item/更相减损法/10277459)。

### 辗转相除法

又称`欧几里得算法`

定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。[最大公约数](https://baike.baidu.com/item/最大公约数)（Greatest Common Divisor）缩写为GCD。

`gcd(a,b) = gcd(b,a mod b) `(不妨设a>b 且r=a mod b ,r不为0)
$$
另 a = k_1b+r\\
b = k_2r + r_1\\
r = k_3r_1+r_2\\
假设r_2为0，那么r = k_3r_1，带入得\\

b = k_2k_3r_1 + r_1\\
a = k_1(k_2k_3r_1 + r_1) + k_3r_1 =  r1(k_1k_2k_3 + 1 + k_3)\\
$$

```java
private int gcd(int a, int b) {
    if (a == b) {
        // 两个数相等，最大公约数就是a或者b
        return a;
    }
    return a == 0 ? b : gcd(a,  % b);
}
```



### 更相减损法

[更相减损法](https://baike.baidu.com/item/更相减损法)：也叫[更相减损术](https://baike.baidu.com/item/更相减损术)，是出自《[九章算术](https://baike.baidu.com/item/九章算术)》的一种求最大公约数的算法，它原本是为[约分](https://baike.baidu.com/item/约分)而设计的，但它适用于任何需要求最大公约数的场合。

以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。

```java
/**
 * 更相减损法求最大公约数
 */
private int gcd(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }

    if (a < 0 || b < 0) {
        throw new IllegalArgumentException("arguments must great zero");
    }
    if (a == b) {
        // 两个数相等，最大公约数就是a或者b
        return a;
    }
    while (a != b) {
        if (a > b) {
            a = a - b;
        } else {
            b = b - a;
        }
    }
    return a;
}
```

### [Stein算法](https://en.wikipedia.org/wiki/Binary_GCD_algorithm)

欧几里德算法是计算两个数最大公约数的传统算法，无论从理论还是从实际效率上都是很好的。但是却有一个致命的缺陷，这个缺陷在素数比较小的时候一般是感觉不到的，只有在大素数时才会显现出来：一般实际应用中的整数很少会超过64位（当然现在已经允许128位了），对于这样的整数，计算两个数之间的模是很简单的。对于字长为32位的平台，计算两个不超过32位的整数的模，只需要一个指令周期，而计算64位以下的整数模，也不过几个周期而已。但是对于更大的素数，这样的计算过程就不得不由用户来设计，为了计算两个超过64位的整数的模，用户也许不得不采用类似于多位数除法手算过程中的试商法，这个过程不但复杂，而且消耗了很多CPU时间。对于现代密码算法，要求计算128位以上的素数的情况比比皆是，比如说RSA加密算法至少要求500bit密钥长度，设计这样的程序迫切希望能够抛弃除法和取模。



Stein算法很好的解决了欧几里德算法中的这个缺陷，Stein算法只有整数的移位和加减法。下面就来说一下Stein算法的原理：

- 若a和b都是偶数，则记录下公约数2，然后都除2（即右移1位）；

- 若其中一个数是偶数，则偶数除2，因为此时2不可能是这两个数的公约数了
- 若两个都是奇数，则a = |a-b|，b = min(a,b)，因为若d是a和b的公约数，那么d也是|a-b|和min(a,b)的公约数。

```java
这里面可能就第三句话难理解一点，这里进行简单的证明：

不妨设奇数A>B，A和B的公约数为X，即A=jX，B=kX，其中j，k均为正整数且j>k。
A−B=(j−k)X
A−B=(j−k)X

因为j，k均为整数，所以X也是A-B的公约数。
min(A,B)=B

所以A-B与min(A,B)公约数相同，因为A，B都是奇数，所以A-B必然是偶数，偶数又可以二除移位了。
```



```java
int steinGCD(int a, int b) {
        if (a == 0 || b == 0) {
            return 0;
        }
        if (a < 0 || b < 0) {
            throw new IllegalArgumentException("arguments must great zero");
        }
        if (a == b) {
            // 两个数相等，最大公约数就是a或者b
            return a;
        }
        if (a < b) {
            int t = a;
            a = b;
            b = t;
        }
        if ((a & 1) == 0 && (b & 1) == 0)
            // 都是偶数
            return steinGCD(a >> 1, b >> 1) << 1;
        else if ((a & 1) == 0 && (b & 1) != 0)
            // a是偶数，b是奇数
            return steinGCD(a >> 1, b);
        else if ((a & 1) != 0 && (b & 1) == 0)
            // a是奇数，b是偶数
            return steinGCD(a, b >> 1);
        else
            // a、b都是奇数
            return steinGCD(a - b, b);
    }
```

```java
int SteinGCD(int a, int b) {
 	if (a == 0 || b == 0) {
            return 0;
        }
        if (a < 0 || b < 0) {
            throw new IllegalArgumentException("arguments must great zero");
        }
        if (a == b) {
            // 两个数相等，最大公约数就是a或者b
            return a;
        }
    int acc = 0;
    while ((a & 1) == 0 && (b & 1) == 0) {
        acc++;
        a >>= 1;
        b >>= 1;
    }
    while ((a & 1) == 0) a >>= 1;
    while ((b & 1) == 0) b >>= 1;
    if (a < b) { int t = a; a = b; b = t; }
    while ((a = (a - b) >> 1) != 0) {
        while ((a & 1) == 0) a >>= 1;
        if (a < b) { int t = a; a = b; b = t; }
    }
    return b << acc;
}
```



## 最小公倍数（Least Common Multiple）

两个或多个[整数](https://baike.baidu.com/item/整数/1293937)公有的[倍数](https://baike.baidu.com/item/倍数/7827981)叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。整数a，b的最小公倍数记为[a，b]，同样的，a，b，c的最小公倍数记为[a，b，c]，多个整数的最小公倍数也有同样的记号。

- 如果两个数是倍数关系，则它们的最小公倍数就是较大的数
- 相邻的两个自然数的最小公倍数是它们的乘积
- 最小公倍数 = 两数的乘积/最大公约（因）数,



